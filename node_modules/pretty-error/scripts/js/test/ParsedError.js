var ParsedError, error, sysPath;

require('./_prepare');

sysPath = require('path');

error = function(what) {
  var e;
  if (typeof what === 'string') {
    return error(function() {
      throw Error(what);
    });
  } else if (what instanceof Function) {
    try {
      what();
      return null;
    } catch (_error) {
      e = _error;
      return e;
    }
  } else {
    throw Error("bad argument for error");
  }
};

ParsedError = mod('ParsedError');

describe("constructor()");

it("should accept Error() instances", function() {
  return (function() {
    var e;
    return e = new ParsedError(error(function() {
      throw Error("some message");
    }));
  }).should.not["throw"]();
});

it("should accept ReferenceError() and other derivatives of Error()", function() {
  return (function() {
    var e;
    return e = new ParsedError(error(function() {
      throw ReferenceError("some message");
    }));
  }).should.not["throw"]();
});

it("should accept non errors", function() {
  return (function() {
    var e;
    return e = new ParsedError('some string');
  }).should.not["throw"]();
});

describe("message");

it("should return the original error message", function() {
  var e;
  e = new ParsedError(error('a'));
  return e.message.should.equal('a');
});

describe("kind");

it("should return 'Error' for normal error", function() {
  var e;
  e = new ParsedError(error('a'));
  return e.kind.should.equal('Error');
});

it("should recognize 'ReferenceError'", function() {
  var e;
  e = new ParsedError(error(function() {
    return a.b = c;
  }));
  return e.kind.should.equal('ReferenceError');
});

describe("type");

it("should return original error type", function() {
  var e;
  e = new ParsedError(error(function() {
    return a.b = c;
  }));
  return expect(e.type).to.equal('not_defined');
});

describe("arguments");

it("should return original error arguments", function() {
  var e;
  e = new ParsedError(error(function() {
    return a.b = c;
  }));
  return expect(e["arguments"]).to.be.like(['a']);
});

describe("stack");

it("should return original error stack", function() {
  var e;
  e = new ParsedError(error(function() {
    return a.b = c;
  }));
  return expect(e.stack).to.equal(e.error.stack);
});

describe("trace");

it("should include correct information about each trace item", function() {
  var e, item;
  e = new ParsedError(error(function() {
    return a.b = c;
  }));
  e.trace.should.have.length.above(2);
  item = e.trace[0];
  item.should.include.keys('original', 'what', 'path', 'addr', 'file', 'dir', 'col', 'line', 'jsCol', 'jsLine', 'packageName', 'shortenedPath', 'shortenedAddr');
  item.path.should.equal(module.filename.replace(/[\\]+/g, '/'));
  item.line.should.be.a('number');
  return item.col.should.be.a('number');
});

describe("_rectifyPath()");

it("should work", function() {
  return ParsedError.prototype._rectifyPath('F:/a/node_modules/b/node_modules/d/node_modules/e/f.js').path.should.equal('[a]/[b]/[d]/[e]/f.js');
});

it("should return path when `node_modules` is not present", function() {
  return ParsedError.prototype._rectifyPath('a/b/c').path.should.equal('a/b/c');
});
